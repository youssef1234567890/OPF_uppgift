@page "/thread/{ThreadId:int}"
@using BlazorApp.Data
@using BlazorApp.Components
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.EntityFrameworkCore
@using Microsoft.AspNetCore.Identity
@using Microsoft.AspNetCore.Components.Web
@attribute [Authorize]
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject ApplicationDbContext dbContext
@inject UserManager<ApplicationUser> UserManager
@inject NavigationManager NavigationManager
@inject IJSRuntime JSRuntime

<div class="container mt-5">
    @if (thread != null)
    {
        <div class="mb-3">
            <a href="/category/@thread.Category" class="btn btn-sm btn-outline-secondary">&laquo; Back to @thread.Category</a>
        </div>

        <ThreadHeader 
            Title="@thread.Title" 
            Description="@thread.Description" 
            Category="@thread.Category" 
            PostedBy="@thread.ApplicationUser?.UserName" 
            CreatedAt="@thread.CreatedAt" 
            CanDelete="@(thread.ApplicationUserId == currentUserId || isAdmin)" 
            OnDelete="DeleteThread" />

        <AuthorizeView>
            <Authorized>
                <div class="card p-4 shadow-sm">
                    <h4 class="mb-4">Messages</h4>

                    <MessageInput 
                        MessageText="@newMessageText" 
                        ReplyingTo="@replyingToMessage" 
                        OnSend="HandleSendMessage" 
                        OnCancelReply="CancelReply" />

                    <MessageList 
                        Messages="@messages" 
                        CurrentUserId="@currentUserId" 
                        IsAdmin="@isAdmin" 
                        OnReply="SetReplyContext" 
                        OnEdit="SaveEdit" 
                        OnDelete="DeleteMessage" />
                </div>
            </Authorized>
            <NotAuthorized>
                <p class="text-center text-danger">You must be logged in to participate in discussions.</p>
            </NotAuthorized>
        </AuthorizeView>
    }
    else
    {
        <div class="alert alert-warning">
            Loading thread information...
        </div>
    }
</div>

@code {
    [Parameter]
    public int ThreadId { get; set; }

    private Thread? thread;
    private List<Message> messages = new();
    private string currentUser = string.Empty;
    private string currentUserId = string.Empty;
    private ApplicationUser currentUserEntity = null!;
    private string newMessageText = string.Empty;
    private string replyingToMessage = string.Empty;
    private bool isAdmin = false;
    
    // For editing messages
    private int editingMessageId = -1;
    private string editMessageText = string.Empty;

    protected override async Task OnInitializedAsync()
    {
        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;

        if (user.Identity is { IsAuthenticated: true })
        {
            currentUser = user.Identity.Name ?? "Unknown";

            var identityUser = await UserManager.FindByNameAsync(currentUser);
            if (identityUser != null)
            {
                currentUserId = identityUser.Id;
                currentUserEntity = identityUser;
                var roles = await UserManager.GetRolesAsync(identityUser);
                isAdmin = roles.Contains("mainadmin") || roles.Contains("admin");
            }
        }

        await LoadThreadData();
    }

    protected override async Task OnParametersSetAsync()
    {
        await LoadThreadData();
    }

    private async Task LoadThreadData()
    {
        thread = await dbContext.Threads
            .Include(t => t.ApplicationUser)
            .FirstOrDefaultAsync(t => t.Id == ThreadId);

        if (thread != null)
        {
            messages = await dbContext.Messages
                .Where(m => m.ThreadId == ThreadId)
                .OrderBy(m => m.Timestamp)
                .Include(m => m.ApplicationUser)
                .ToListAsync();
        }
    }

    private async Task HandleSendMessage(string messageText)
    {
        if (!string.IsNullOrWhiteSpace(messageText) && thread != null)
        {
            var message = new Message
            {
                ApplicationUserId = currentUserId,
                ApplicationUser = currentUserEntity,
                Text = messageText,
                Timestamp = DateTime.UtcNow,
                ThreadId = ThreadId,
                Thread = thread,
                ReplyTo = replyingToMessage,
                ChatRoom = thread.Title
            };

            dbContext.Messages.Add(message);
            await dbContext.SaveChangesAsync();

            messages.Add(message); // Add the new message to the list
            newMessageText = string.Empty; // Clear the input field
            replyingToMessage = string.Empty; // Clear the reply context

            StateHasChanged(); // Trigger UI update
        }
    }

    private async Task HandleKeyPress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            await HandleSendMessage(newMessageText); // Call HandleSendMessage with the current message text
        }
    }

    private async Task DeleteMessage(int messageId)
    {
        var message = await dbContext.Messages.FindAsync(messageId);
        if (message != null && (message.ApplicationUserId == currentUserId || isAdmin))
        {
            dbContext.Messages.Remove(message);
            await dbContext.SaveChangesAsync();

            messages.RemoveAll(m => m.Id == messageId || m.ReplyTo == messageId.ToString());
            StateHasChanged();
        }
    }

    private async Task DeleteReplies(int parentMessageId)
    {
        // Find all replies to the parent message
        var replies = await dbContext.Messages
            .Where(m => m.ReplyTo == parentMessageId.ToString())
            .ToListAsync();

        foreach (var reply in replies)
        {
            // Recursively delete replies to this reply
            await DeleteReplies(reply.Id);

            // Remove the reply from the database
            dbContext.Messages.Remove(reply);
        }

        // Save changes after all replies are removed
        await dbContext.SaveChangesAsync();
    }

    private async Task DeleteThread()
    {
        bool confirmed = await JSRuntime.InvokeAsync<bool>("confirm", "Are you sure you want to delete this thread? This will permanently remove all messages and cannot be undone.");
        if (!confirmed)
            return;
            
        if (thread != null && (thread.ApplicationUserId == currentUserId || isAdmin))
        {
            // First, delete all messages in the thread
            var threadMessages = await dbContext.Messages
                .Where(m => m.ThreadId == ThreadId)
                .ToListAsync();
                
            dbContext.Messages.RemoveRange(threadMessages);
            
            // Then delete the thread itself
            dbContext.Threads.Remove(thread);
            await dbContext.SaveChangesAsync();
            
            await JSRuntime.InvokeVoidAsync("alert", "Thread deleted successfully");
            
            // Navigate back to the category page
            NavigationManager.NavigateTo($"/category/{thread.Category}");
        }
    }

    private void SetReplyContext(Message message)
    {
        string messagePreview = message.Text.Length > 50 ? message.Text.Substring(0, 47) + "..." : message.Text;
        replyingToMessage = $"{message.UserName}: {messagePreview}";
    }

    private void CancelReply()
    {
        replyingToMessage = string.Empty;
    }
    
    // Message editing functionality
    private void StartEdit(Message message)
    {
        editingMessageId = message.Id;
        editMessageText = message.Text;
    }
    
    private void CancelEdit()
    {
        editingMessageId = -1;
        editMessageText = string.Empty;
    }
    
    private async Task SaveEdit(Message message)
    {
        var messageToUpdate = await dbContext.Messages.FindAsync(message.Id);
        if (messageToUpdate != null && (messageToUpdate.ApplicationUserId == currentUserId || isAdmin))
        {
            messageToUpdate.Text = message.Text;
            await dbContext.SaveChangesAsync();
            
            // Update the message in our local collection
            var index = messages.FindIndex(m => m.Id == message.Id);
            if (index >= 0)
            {
                messages[index].Text = message.Text;
            }
            
            StateHasChanged();
        }
    }
}
